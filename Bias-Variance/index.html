<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bias-Variance Tradeoff Demonstration</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .subtitle {
            text-align: center;
            color: #7f8c8d;
            margin-bottom: 30px;
            font-size: 1.2em;
        }

        .demo-section {
            margin: 30px 0;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 5px solid #3498db;
        }

        .demo-section h2 {
            color: #2c3e50;
            margin-top: 0;
            display: flex;
            align-items: center;
        }

        .demo-section h2::before {
            content: "ðŸŽ¯";
            margin-right: 10px;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin: 20px 0;
            align-items: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-weight: bold;
            color: #2c3e50;
        }

        .slider {
            width: 200px;
            height: 8px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        button {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.2);
        }

        button:active {
            transform: translateY(0);
        }

        .canvas-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        canvas {
            border: 2px solid #ddd;
            border-radius: 8px;
            background: white;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .metric-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            border-top: 4px solid #3498db;
        }

        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #2c3e50;
        }

        .metric-label {
            color: #7f8c8d;
            margin-top: 5px;
        }

        .explanation {
            background: #e8f4f8;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 5px solid #3498db;
        }

        .bias-high { border-top-color: #e74c3c; }
        .variance-high { border-top-color: #f39c12; }
        .optimal { border-top-color: #27ae60; }

        .teaching-points {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .teaching-points h3 {
            color: #856404;
            margin-top: 0;
        }

        .teaching-points ul {
            margin: 0;
            padding-left: 20px;
        }

        .teaching-points li {
            margin: 8px 0;
            color: #856404;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
            }
            
            .canvas-container {
                grid-template-columns: 1fr;
            }
            
            .metrics {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽ¯ Bias-Variance Tradeoff</h1>
        <p class="subtitle">Interactive Demonstration of Machine Learning's Fundamental Tradeoff</p>

        <div class="demo-section">
            <h2>Understanding the Tradeoff</h2>
            <div class="explanation">
                <p><strong>The bias-variance tradeoff</strong> is one of the most important concepts in machine learning. It helps us understand why models sometimes fail to generalize well to new data.</p>
                <ul>
                    <li><strong>Bias:</strong> Error from overly simplistic assumptions (underfitting)</li>
                    <li><strong>Variance:</strong> Error from sensitivity to small fluctuations in training data (overfitting)</li>
                    <li><strong>Goal:</strong> Find the sweet spot that minimizes total error</li>
                </ul>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="complexitySlider">Model Complexity</label>
                    <input type="range" id="complexitySlider" class="slider" min="1" max="15" value="3">
                    <span id="complexityValue">3</span>
                </div>
                
                <div class="control-group">
                    <label for="noiseSlider">Data Noise Level</label>
                    <input type="range" id="noiseSlider" class="slider" min="0.05" max="0.3" step="0.05" value="0.1">
                    <span id="noiseValue">0.1</span>
                </div>
                
                <div class="control-group">
                    <label for="samplesSlider">Training Samples</label>
                    <input type="range" id="samplesSlider" class="slider" min="20" max="200" step="20" value="100">
                    <span id="samplesValue">100</span>
                </div>
                
                <button onclick="runExperiment()">ðŸ”„ Run New Experiment</button>
                <button onclick="runBiasVarianceAnalysis()">ðŸ“Š Analyze Bias-Variance</button>
            </div>

            <div class="canvas-container">
                <canvas id="dataCanvas" width="350" height="300"></canvas>
                <canvas id="modelCanvas" width="350" height="300"></canvas>
                <canvas id="biasVarianceCanvas" width="350" height="300"></canvas>
            </div>

            <div class="metrics">
                <div class="metric-card bias-high">
                    <div class="metric-value" id="biasValue">-</div>
                    <div class="metric-label">BiasÂ²</div>
                </div>
                <div class="metric-card variance-high">
                    <div class="metric-value" id="varianceValue">-</div>
                    <div class="metric-label">Variance</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="noiseValueMetric">-</div>
                    <div class="metric-label">Irreducible Error</div>
                </div>
                <div class="metric-card optimal">
                    <div class="metric-value" id="totalErrorValue">-</div>
                    <div class="metric-label">Total Error</div>
                </div>
            </div>
        </div>

        <div class="teaching-points">
            <h3>ðŸŽ“ Key Teaching Points</h3>
            <ul>
                <li><strong>Low Complexity (High Bias):</strong> Model is too simple, misses important patterns</li>
                <li><strong>High Complexity (High Variance):</strong> Model learns noise, doesn't generalize</li>
                <li><strong>Sweet Spot:</strong> Balance between bias and variance minimizes total error</li>
                <li><strong>More Data:</strong> Generally reduces variance but doesn't fix bias</li>
                <li><strong>Regularization:</strong> Technique to control this tradeoff</li>
            </ul>
        </div>
    </div>

    <script>
        // Global variables
        let currentExperiment = null;
        let biasVarianceResults = null;

        // True function for generating data
        function trueFunction(x) {
            return 0.5 * x + 0.3 * Math.sin(15 * x) + 0.1 * x * x;
        }

        // Generate random data
        function generateData(nSamples, noiseLevel) {
            const data = [];
            for (let i = 0; i < nSamples; i++) {
                const x = (Math.random() - 0.5) * 2; // Range [-1, 1]
                const y = trueFunction(x) + (Math.random() - 0.5) * 2 * noiseLevel;
                data.push({x, y});
            }
            return data.sort((a, b) => a.x - b.x);
        }

        // Polynomial regression
        function polynomialRegression(data, degree) {
            const n = data.length;
            const m = degree + 1;
            
            // Create design matrix
            const X = [];
            const y = [];
            
            for (let i = 0; i < n; i++) {
                const row = [];
                for (let j = 0; j <= degree; j++) {
                    row.push(Math.pow(data[i].x, j));
                }
                X.push(row);
                y.push(data[i].y);
            }
            
            // Solve normal equations (simplified for demo)
            const coefficients = solveLinearSystem(X, y);
            
            return function(x) {
                let result = 0;
                for (let i = 0; i <= degree; i++) {
                    result += coefficients[i] * Math.pow(x, i);
                }
                return result;
            };
        }

        // Simplified linear system solver
        function solveLinearSystem(X, y) {
            const n = X.length;
            const m = X[0].length;
            
            // Create XTX and XTy
            const XTX = Array(m).fill().map(() => Array(m).fill(0));
            const XTy = Array(m).fill(0);
            
            for (let i = 0; i < m; i++) {
                for (let j = 0; j < m; j++) {
                    for (let k = 0; k < n; k++) {
                        XTX[i][j] += X[k][i] * X[k][j];
                    }
                }
                for (let k = 0; k < n; k++) {
                    XTy[i] += X[k][i] * y[k];
                }
            }
            
            // Simple Gaussian elimination (works for small matrices)
            return gaussianElimination(XTX, XTy);
        }

        function gaussianElimination(A, b) {
            const n = A.length;
            const Ab = A.map((row, i) => [...row, b[i]]);
            
            // Forward elimination
            for (let i = 0; i < n; i++) {
                // Find pivot
                let maxRow = i;
                for (let k = i + 1; k < n; k++) {
                    if (Math.abs(Ab[k][i]) > Math.abs(Ab[maxRow][i])) {
                        maxRow = k;
                    }
                }
                [Ab[i], Ab[maxRow]] = [Ab[maxRow], Ab[i]];
                
                // Make all rows below this one 0 in current column
                for (let k = i + 1; k < n; k++) {
                    if (Math.abs(Ab[i][i]) < 1e-10) continue;
                    const c = Ab[k][i] / Ab[i][i];
                    for (let j = i; j <= n; j++) {
                        Ab[k][j] -= c * Ab[i][j];
                    }
                }
            }
            
            // Back substitution
            const x = Array(n).fill(0);
            for (let i = n - 1; i >= 0; i--) {
                x[i] = Ab[i][n];
                for (let j = i + 1; j < n; j++) {
                    x[i] -= Ab[i][j] * x[j];
                }
                if (Math.abs(Ab[i][i]) > 1e-10) {
                    x[i] /= Ab[i][i];
                }
            }
            
            return x;
        }

        // Drawing functions
        function drawData(canvas, data, model = null) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, width, height);
            
            // Set up coordinate system
            const padding = 40;
            const plotWidth = width - 2 * padding;
            const plotHeight = height - 2 * padding;
            
            const xMin = -1, xMax = 1;
            const yMin = -1, yMax = 1;
            
            function scaleX(x) {
                return padding + ((x - xMin) / (xMax - xMin)) * plotWidth;
            }
            
            function scaleY(y) {
                return height - padding - ((y - yMin) / (yMax - yMin)) * plotHeight;
            }
            
            // Draw axes
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(scaleX(0), padding);
            ctx.lineTo(scaleX(0), height - padding);
            ctx.moveTo(padding, scaleY(0));
            ctx.lineTo(width - padding, scaleY(0));
            ctx.stroke();
            
            // Draw true function
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 3;
            ctx.beginPath();
            let first = true;
            for (let x = xMin; x <= xMax; x += 0.01) {
                const y = trueFunction(x);
                if (first) {
                    ctx.moveTo(scaleX(x), scaleY(y));
                    first = false;
                } else {
                    ctx.lineTo(scaleX(x), scaleY(y));
                }
            }
            ctx.stroke();
            
            // Draw model if provided
            if (model) {
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 2;
                ctx.beginPath();
                first = true;
                for (let x = xMin; x <= xMax; x += 0.01) {
                    const y = model(x);
                    if (y > yMin && y < yMax) {
                        if (first) {
                            ctx.moveTo(scaleX(x), scaleY(y));
                            first = false;
                        } else {
                            ctx.lineTo(scaleX(x), scaleY(y));
                        }
                    }
                }
                ctx.stroke();
            }
            
            // Draw data points
            ctx.fillStyle = '#3498db';
            data.forEach(point => {
                ctx.beginPath();
                ctx.arc(scaleX(point.x), scaleY(point.y), 4, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            // Add labels
            ctx.fillStyle = '#2c3e50';
            ctx.font = '12px Arial';
            ctx.fillText('True Function (black)', 10, 20);
            if (model) {
                ctx.fillText('Model Prediction (red)', 10, 35);
            }
            ctx.fillText('Training Data (blue)', 10, 50);
        }

        function drawBiasVarianceChart(canvas, results) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, width, height);
            
            if (!results) return;
            
            const padding = 40;
            const plotWidth = width - 2 * padding;
            const plotHeight = height - 2 * padding;
            
            const complexities = Object.keys(results).map(Number).sort((a, b) => a - b);
            const maxError = Math.max(...complexities.map(c => results[c].totalError));
            
            function scaleX(complexity, index) {
                return padding + (index / (complexities.length - 1)) * plotWidth;
            }
            
            function scaleY(error) {
                return height - padding - (error / maxError) * plotHeight;
            }
            
            // Draw axes
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            // Draw bias line
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 2;
            ctx.beginPath();
            complexities.forEach((c, i) => {
                const y = scaleY(results[c].bias);
                if (i === 0) ctx.moveTo(scaleX(c, i), y);
                else ctx.lineTo(scaleX(c, i), y);
            });
            ctx.stroke();
            
            // Draw variance line
            ctx.strokeStyle = '#f39c12';
            ctx.lineWidth = 2;
            ctx.beginPath();
            complexities.forEach((c, i) => {
                const y = scaleY(results[c].variance);
                if (i === 0) ctx.moveTo(scaleX(c, i), y);
                else ctx.lineTo(scaleX(c, i), y);
            });
            ctx.stroke();
            
            // Draw total error line
            ctx.strokeStyle = '#27ae60';
            ctx.lineWidth = 3;
            ctx.beginPath();
            complexities.forEach((c, i) => {
                const y = scaleY(results[c].totalError);
                if (i === 0) ctx.moveTo(scaleX(c, i), y);
                else ctx.lineTo(scaleX(c, i), y);
            });
            ctx.stroke();
            
            // Add legend
            ctx.fillStyle = '#2c3e50';
            ctx.font = '12px Arial';
            ctx.fillText('BiasÂ² (red)', 10, 20);
            ctx.fillText('Variance (orange)', 10, 35);
            ctx.fillText('Total Error (green)', 10, 50);
            
            // Mark optimal point
            const optimalComplexity = complexities.reduce((best, current) => 
                results[current].totalError < results[best].totalError ? current : best
            );
            const optimalIndex = complexities.indexOf(optimalComplexity);
            
            ctx.fillStyle = '#8e44ad';
            ctx.beginPath();
            ctx.arc(scaleX(optimalComplexity, optimalIndex), 
                   scaleY(results[optimalComplexity].totalError), 8, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillText('Optimal', scaleX(optimalComplexity, optimalIndex) - 20, 
                        scaleY(results[optimalComplexity].totalError) - 15);
        }

        // Event handlers
        function updateSliderValues() {
            document.getElementById('complexityValue').textContent = 
                document.getElementById('complexitySlider').value;
            document.getElementById('noiseValue').textContent = 
                document.getElementById('noiseSlider').value;
            document.getElementById('samplesValue').textContent = 
                document.getElementById('samplesSlider').value;
        }

        function runExperiment() {
            const complexity = parseInt(document.getElementById('complexitySlider').value);
            const noiseLevel = parseFloat(document.getElementById('noiseSlider').value);
            const nSamples = parseInt(document.getElementById('samplesSlider').value);
            
            // Generate new data
            const data = generateData(nSamples, noiseLevel);
            
            // Train model
            const model = polynomialRegression(data, complexity);
            
            // Store current experiment
            currentExperiment = { data, model, complexity, noiseLevel };
            
            // Update visualizations
            const dataCanvas = document.getElementById('dataCanvas');
            const modelCanvas = document.getElementById('modelCanvas');
            
            drawData(dataCanvas, data);
            drawData(modelCanvas, data, model);
            
            // Update noise metric
            document.getElementById('noiseValueMetric').textContent = 
                (noiseLevel * noiseLevel).toFixed(4);
        }

        function runBiasVarianceAnalysis() {
            const noiseLevel = parseFloat(document.getElementById('noiseSlider').value);
            const nSamples = parseInt(document.getElementById('samplesSlider').value);
            const nExperiments = 20; // Reduced for browser performance
            
            const complexitiesToTest = [1, 3, 5, 7, 9, 12];
            const results = {};
            
            // Test points for evaluation
            const testPoints = [];
            for (let x = -1; x <= 1; x += 0.1) {
                testPoints.push(x);
            }
            
            complexitiesToTest.forEach(complexity => {
                const predictions = [];
                
                // Run multiple experiments
                for (let exp = 0; exp < nExperiments; exp++) {
                    const data = generateData(nSamples, noiseLevel);
                    const model = polynomialRegression(data, complexity);
                    
                    const expPredictions = testPoints.map(x => model(x));
                    predictions.push(expPredictions);
                }
                
                // Calculate bias and variance
                const truePredictions = testPoints.map(x => trueFunction(x));
                const meanPredictions = testPoints.map((_, i) => {
                    return predictions.reduce((sum, pred) => sum + pred[i], 0) / nExperiments;
                });
                
                const bias = truePredictions.reduce((sum, true_y, i) => {
                    return sum + Math.pow(meanPredictions[i] - true_y, 2);
                }, 0) / testPoints.length;
                
                const variance = testPoints.reduce((sum, _, i) => {
                    const pointVariance = predictions.reduce((vSum, pred) => {
                        return vSum + Math.pow(pred[i] - meanPredictions[i], 2);
                    }, 0) / nExperiments;
                    return sum + pointVariance;
                }, 0) / testPoints.length;
                
                const noise = noiseLevel * noiseLevel;
                const totalError = bias + variance + noise;
                
                results[complexity] = { bias, variance, noise, totalError };
            });
            
            biasVarianceResults = results;
            
            // Update metrics for current complexity
            const currentComplexity = parseInt(document.getElementById('complexitySlider').value);
            const closest = complexitiesToTest.reduce((prev, curr) => 
                Math.abs(curr - currentComplexity) < Math.abs(prev - currentComplexity) ? curr : prev
            );
            
            if (results[closest]) {
                document.getElementById('biasValue').textContent = results[closest].bias.toFixed(4);
                document.getElementById('varianceValue').textContent = results[closest].variance.toFixed(4);
                document.getElementById('totalErrorValue').textContent = results[closest].totalError.toFixed(4);
            }
            
            // Update chart
            const biasVarianceCanvas = document.getElementById('biasVarianceCanvas');
            drawBiasVarianceChart(biasVarianceCanvas, results);
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            // Set up event listeners
            document.getElementById('complexitySlider').addEventListener('input', updateSliderValues);
            document.getElementById('noiseSlider').addEventListener('input', updateSliderValues);
            document.getElementById('samplesSlider').addEventListener('input', updateSliderValues);
            
            // Initial setup
            updateSliderValues();
            runExperiment();
            setTimeout(runBiasVarianceAnalysis, 500); // Small delay for better UX
        });
    </script>
</body>
</html>
